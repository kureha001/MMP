# Python版 はじめに

本書は、アプリ開発者が **MMP.py** を入り口として MMP ライブラリを利用するための手引きです。  
**接続指定子（ConnSpec）**を 1 本化し、プラットフォーム差（CPython / MicroPython / CircuitPython / TCPブリッジ）を **MMP.py が自動で吸収**します。

---

## 1. 目的と全体像

- 上位アプリは **`MMP.py`** だけを入口に使用します。
- `conn` 文字列（ConnSpec）で「どの接続か」を指定すると、**MMP.py が適切なアダプタを選択**します。
- コアの API や下位レイヤは変更不要です（完全分離）。

```
App ── MMP.py（AdapterFactory） ── mmp_adapter_*（通信層） ── mmp_core（機能API）
```

---

## 2. 配置（ファイル名を固定化）

以下のファイルを**アプリと同じフォルダ** または **PYTHONPATH** に配置してください。

|ファイル名|内容|
|----|----|
| `MMP.py`|本書の入口|
| `mmp_core.py`|機能API・ロジック|
| `mmp_adapter_base.py`|アダプタ抽象クラス|
| `mmp_adapter_cpython.py`|CPythonアダプタ|
| `mmp_adapter_micro.py` |MicroPythonアダプタ|
| `mmp_adapter_circuit.py`|CircuitPythonアダプタ|
| `mmp_adapter_tcp.py` |TCPブリッジ[CPython]アダプタ|

---

## 3. 使い方（最短）

### 3.1 `new_client()` を使う
```python
from MMP import new_client

# TCP（ser2net の socket:// を想定）
cli = new_client("tcp://192.168.2.113:3331?timeout=0.2")

# 直結（USBシリアルを自動判定。CPython/Micro/Circuit を実行系で自動切替）
cli = new_client("auto")

# 接続（最初に見つかった通信速度で接続）
if cli.ConnectAutoBaud():
    print("Port :", cli.ConnectedPort)
    print("Baud :", cli.ConnectedBaud)
    print("VER  :", cli.Info.Version())
else:
    print("接続失敗:", cli.LastError)
```

### 3.2 `MmpAdapterFactory()` を直接使う
```python
from mmp_core import MmpClient
from MMP      import MmpAdapterFactory

cli = MmpClient(MmpAdapterFactory(conn="tcp://192.168.2.113:3331"))
```

---

## 4. ConnSpec（接続指定子）の書式

- **TCP（ser2net）**：`tcp://<host>:<port>[?timeout=<sec>]`  
  例）`tcp://192.168.2.113:3331?timeout=0.2`  
  - `timeout` は受信待ち（1文字読み）に用いる秒数。省略可（既定 0.2）

- **自動（直結）**：`auto`  
  実行系（CPython / MicroPython / CircuitPython）に応じて該当アダプタを自動選択します。  
  - CPython：COM総当たりの既存挙動
  - MicroPython / CircuitPython：各実装へ委譲

> 既存の「アダプタを直接 new」するコードも動作しますが、**新規開発は ConnSpec の利用を推奨**します。

---

## 5. よく使う API（`mmp_core.MmpClient`）

### 5.1 接続関連
```python
cli.ConnectAutoBaud(candidates=None)  # 既定の候補ボーレート列で試行
cli.ConnectWithBaud(baud, timeoutIo=0, verifyTimeoutMs=0)
cli.Close()

cli.IsOpen         # True/False
cli.ConnectedPort  # 文字列（例: "tcp://192.168.2.113:3331"）
cli.ConnectedBaud  # int または None（TCPでは記録のみ）
cli.LastError      # 直近のエラー文字列
```

### 5.2 情報
```python
cli.Info.Version()           # "VER!" 応答（5文字）
cli.Info.Dev.Pwm(0)          # PCA9685 情報（例）
cli.Info.Dev.Audio(1)        # DFPlayer 情報（例）
```

### 5.3 デジタル I/O
```python
cli.Digital.In(gpioId)           # 0/1
cli.Digital.Out(gpioId, 0 or 1)  # True/False
```

### 5.4 アナログ
```python
cli.Analog.Update()
val = cli.Analog.Read(hc4067ch0to15, hc4067dev0to3)
val = cli.Analog.ReadRound(ch, dev, step, bits=0)
```

### 5.5 PWM / サーボ
```python
cli.Pwm.Dev(0)
cli.Pwm.Out(chId, pwm0to4095)
cli.Pwm.AngleInit(angleMin, angleMax, pwmMin, pwmMax)
cli.Pwm.AngleOut(chId, angle0to180)
```

### 5.6 オーディオ（例）
```python
cli.Audio.Play.Start(devId1to4, index00to99)
cli.Audio.Play.Stop(devId1to4)
cli.Audio.Read.State(devId1to4)
```

### 5.7 I2C
```python
cli.I2c.Write(addr, reg, val)
v = cli.I2c.Read(addr, reg)
```

> 具体的な引数範囲やタイムアウトは、`mmp_core.py` の該当メソッドを参照してください。

---

## 6. 既存コードからの移行

**Before（旧方式：アダプタ直指定）**
```python
from mmp_core    import MmpClient
from mmp_adapter import MmpAdapter  # ← 環境ごとにリネームが必要だった

cli = MmpClient(MmpAdapter())
```

**After（新方式：ConnSpec で統一）**
```python
from MMP import new_client
cli = new_client("tcp://192.168.2.113:3331")  # または "auto"
```

> リネーム運用が不要になり、アプリ側の修正は `conn` 文字列だけになります。

---

## 7. 例：最小アプリ（TCP）

```python
from MMP import new_client

def main():
    cli = new_client("tcp://192.168.2.113:3331?timeout=0.2")
    if not cli.ConnectAutoBaud():
        print("接続失敗:", cli.LastError)
        return

    print("VER :", cli.Info.Version())
    cli.Digital.Out(10, 1)
    cli.Pwm.Out(0, 2048)

if __name__ == "__main__":
    main()
```

---

## 8. トラブルシューティング

- **接続できない**  
  - TCP の場合：`host:port` が正しいか、ser2net が LISTEN しているか（`ss -tlnp`）を確認。  
  - 直結の場合：実行系に応じたアダプタが存在するか（`mmp_adapter_cpython.py` 等が配置されているか）。

- **タイムアウトが頻発する**  
  - `conn="tcp://...?...timeout=0.2"` の値を 0.5 などに増やす。  
  - ネットワーク回線や無線の品質を確認（Wi-Fi→有線で改善）。

- **どのアダプタが選ばれたか知りたい**  
  - `cli.ConnectedPort` を出力（TCP なら `tcp://...`、直結なら物理ポート名）。

---

## 9. 補足：ser2net について（TCP 利用時）

- Raspberry Pi で USB シリアルを TCP にブリッジするデーモンです。  
- v3.5 の最小設定例：
  ```conf
  3331:raw:0:/dev/ttyACM0:115200 8DATABITS NONE 1STOPBIT -XONXOFF -RTSCTS -LOCAL
  ```
- 詳細は「ser2net 運用ドキュメント」を参照してください。

---

## 10. 連携テスト（チェックリスト）

- [ ] `conn="tcp://..."` で接続／`VER!` 応答取得  
- [ ] `conn="auto"` で直結（CPython/Micro/Circuit それぞれ）  
- [ ] デジタル／アナログ／PWM／I2C の基本操作が成功  
- [ ] 切断後の再接続が成功（`Close()` → `ConnectAutoBaud()`）

---

以上で、**MMP.py を介した統一的な利用方法**は完了です。  
アプリ開発者は **ConnSpec だけ** を意識すれば運用可能です。
