# MMP Firmware の 特徴
---

#### このファームウェアを一言で説明すると？
**「通信経路の違いを完全に吸収し、  
すべての制御を '文字列コマンド' に統一した、  
拡張性と教育性に優れたマルチモジュール制御ファームウェア」**

---

## 1. 全体アーキテクチャ概要
MMP Firmware は、複数の通信経路（USB-CDC、UART、TCP Bridge、HTTP Web API）を単一のパーサーへ集約し、  
コマンド処理（MMP Command）を統一ルートで処理するマルチクライアント対応ファームウェアである。

- **クライアント識別はすべてファームウェア側で実施**  
- **ドライバ側（Python / Arduino / .NET）は、通信経路を意識せずに利用可能**  
- **モジュール構成（INFO / ANALOG / DIGITAL / PWM / I2C / MP3）は完全に独立し、高い保守性を持つ**

---

## 2. クライアント管理と経路統合
### ● 経路一覧
| 経路 | ID | 説明 |
|------|-----|------|
| USB CDC | 0 | PC接続用 |
| UART0 | 1 | GPIO Serial |
| TCP Bridge | 2〜11 | IPごとに最大10クライアント |
| HTTP Web API | 12〜21 | IPごとに最大10クライアント |

### ● 特徴
- 動的に IP を登録するので、複数デバイスの同時接続に強い  
- 任意の経路から同一コマンド体系を実行可能  
- 経路数増加（LoRa、BLE など）にも拡張しやすい

---

## 3. モジュール構成
各機能（INFO, ANALOG, DIGITAL, PWM, I2C, MP3）は ModuleBase を継承し、以下の特徴を持つ。

- **コマンド所有判定 (`owns()`) と処理本体 (`handle()`) の明確な分離**
- LED 点灯用の RAII ガード  
- 出力は **仮想ストリーム StringStream** へ統一  
- モジュール追加/削除が非常に簡単

---

## 4. パーサーの設計（fnPerser.h）
- すべての経路からのリクエストは **MMP_REQUEST → パーサー → モジュール** の流れに統一
- パース方式は  
  **`コマンド:引数1:引数2:...!`**  
  の軽量プロトコル
- C 言語に近い領域管理（固定長バッファ）で信頼性を確保
- モジュール毎の独立性が高く、規模が大きくなっても破綻しない

---

## 5. MMP Firmware の技術的アピールポイント（部外者向け）
### 🔹 **（1）完全マルチクライアント対応**
- USB / UART / TCP / HTTP を同時に扱える  
- 各クライアントは独立したバッファ・独立したセッションを保持  
- アナログ・PWMなど全データは「クライアントごとに完全分離」

### 🔹 **（2）モジュールが完全に独立して動作**
- 各機能は独立したクラスとして実装  
- 機能追加は「ファイル 1 枚追加するだけ」で可能  
- 依存関係が小さく、学習教材としても最適

### 🔹 **（3）通信経路を意識しない共通インターフェース**
Python / Arduino / .NET からは、  
**`send("ANALOG/IN!")` のように文字列を送るだけ**。

内部でのクライアントID割当、IPスロット管理などはすべてファームウェアが担当。

→ **アプリ側は常に同一APIで使えるため、実装ミスが減る**

### 🔹 **（4）安全性の高い RAII / 固定長バッファ設計**
- LED 点灯は RAII（スコープガード）で安全に実行  
- StringStream への出力も RAIIで安全に退避  
- Stack/Heap を最小限に抑え、ESP32-S3でも安定動作

### 🔹 **（5）拡張性の高さ**
- LoRa / BLE / USB-HID / WebSocket なども追加が容易  
- IPスロット方式なので、無限にクライアント追加が可能  
- PWM / アナログ / MP3 / I2C のようなデバイス制御もモジュール化済み  

---
## まとめると

- **どの通信方式でも自動識別**
USB、UART、TCP、HTTP すべてを自動判別し、アプリ側での分岐が不要

- **クライアントごとの状態管理**
最大22クライアントの独立したアナログ値・PWMプリセット・設定を自動保持

- **通信方式追加でもアプリ修正不要**
新方式は新しいクライアントIDとして扱われ、アプリ側は変更なし

- **アプリ開発が圧倒的に簡単**
クライアントID管理、バッファ初期化、個別状態保持などを全てFW側が実施

- **統一コマンド体系で全言語共通**
Python / Arduino / .NET / Web すべてが同じフォーマットで操作可能

---
