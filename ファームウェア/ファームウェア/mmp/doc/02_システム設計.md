# 📘 システム設計

---

## 1. システム概要

- **複数ストリーム待受**：全経路を順次ポーリングし、受信終端 `'!'` で1コマンド確定 → ルーティング。  
- **モジュール分割**：機能は `ModuleBase` を継承した各モジュールに実装。  
- **RAIIガード**：
  - `SerialScope`…処理区間だけ**出力先ストリームを一時切り替え**、スコープ終了で自動復元  
  - `LedScope`……処理区間だけ**NeoPixel点灯**、スコープ終了で自動消灯
- **プロトコル**：
  - 受信：`:` 区切りトークン（最大5個×各10文字、行最大96文字）＋終端 `'!'`  
  - 応答：コマンドにより可変（例：`VER` は `"0401!"`）。未定義コマンドは `"XXX?!"` 形式で返却

---

## 2. ファイル一覧

| ファイル名 | 役割 |
|---|---|
| `mmpNew.ino` | 全体の初期化、全通信経路のポーリングをループ実行 |
| `cli.h` | 経路共通の情報やユーティリティ|
| `cliSerial.h` | **シリアル通信**のポーリング処理|
| `cliNet.h` | **Wi-Fi接続**をおこない、`TCP Bridge` `Web-API`のサーバーを起動|
| `cliTCP.h` | **TCP Bridge**のサーバ構築、ポーリング処理|
| `cliHTTP.h` | **Web-API**のサーバ構築、ポーリング処理|
| `parser.h` | 全経路共通のハブ機能(`クライアント←→機能モジュール`)<br>リクエスト→トークン化→機能モジュール連携→レスポンス |
| `mod.h` | 共有**コンテクスト**、**RAIIガード**（`SerialScope`/`LedScope`）、機能モジュール基底クラス、**LEDパレット定義** |
| `modINF.h` | 情報系（例：`VER` 応答） |
| `modANA.h` | アナログ入力<br>※個別の初期化処理あり|
| `modDIG.h` | GPIO デジタル入出力 |
| `modPWM.h` | PWM／サーボ角度／ローテーションサーボ<br>※個別の初期化処理あり|
| `modI2C.h` | I2C 読み書き |
| `modMP3.h` | 音声プレイヤー制御<br>※個別の初期化処理あり |

---

## 4. コマンドの追加／修正／削除

### 追加（既存モジュール）
1. 対象 `ModuleX.h` を開く  
2. `owns()` に新コマンド名を判定追加  
3. `handle()` に処理分岐を追加  
   - 先頭で `LedScope led_guard(ctx, led);`（点灯区間の可視化）  
   - **出力は `MMP_SERIAL(ctx)` 経由**（ルーターが `SerialScope` 済み）  
4. 応答仕様を満たす（成功/失敗の整合）。未定義コマンドはルーター側で `"XXX?!"` 返却済み

### 修正
- `handle()` 内のロジックを更新。**引数数 `dat_cnt` と各トークン長（≤10）**を厳密チェック

### 削除
- `owns()` の該当名を外し、`handle()` 側の分岐を削除

> 受信制限：`MMP_INPUT_LINE_LENGTH=96`、`MMP_INPUT_DAT_COUNT=5`、`MMP_INPUT_DAT_LENGTH=10`（`Perser.h`）

---

## 5. モジュールの追加／削除

### 追加
1. `ModuleX.h` を作成し `ModuleBase` を継承
2. `owns()` と `handle()` を実装  
   - `handle()` 冒頭に `LedScope led_guard(ctx, led);`  
3. `mmpDete.ino` の `setup()` で登録  
   ```cpp
   g_router.addModule(new ModuleX(g_ctx, LED_PALETTE_XXXX));
   ```
4. 必要に応じて `ModuleBase.h` の LED パレットに色を追加

### 削除
- `setup()` の `addModule(new ModuleX(...))` を削除し、不要な `#include` を外す

> メモ：`addModule(new ...)` は**ヒープ確保**です。ファームのライフタイムと同一でリーク実害はありませんが、将来の動的 unload を見据えるなら `std::unique_ptr` 化を検討。

---

## 6. ルーターと入出力

- **クライアント登録**（`setup()`）
  ```cpp
  g_router.addSource(&Serial,  "USB",   0);
  g_router.addSource(&Serial1, "UART0", 1);
  ```
- **受信～実行**  
  `pollAll()` が各 `Stream` をポーリング → `'!'` で1コマンド確定 →  
  `runCommand()` が `:` で分割 → `SerialScope` で出力先切替 → `modules` 走査  
- **未定義コマンド**  
  先頭3文字＋`"?!"` を返却（例：`"ABC?!"`）

---

## 7. ボーレート設定と LED 表示（起動時）

- **DIP/SW**：`SW_PIN_A=2`、`SW_PIN_B=6`、`SW_PIN_C=7`（`INPUT_PULLUP`）  
- **組合せで 8段階**：`BAUD_PRESETS = {921600, 57600, 38400, 19200, 9600, 4800, 2400, 300}`  
- **色表示**：`BAUD_COLORS`（GRB順で設定）。起動直後に現在設定を NeoPixel 0番へ点灯

---

## 8. 実装ガイド（小さな約束事）

- **出力は常に `MMP_SERIAL(ctx)`**：出力先はルーターが `SerialScope` で切替済み
- **区間の可視化**：各 `handle()` の冒頭で `LedScope` を置き、**早期 return でも自動消灯**を保証
- **NeoPixel 色順**：`pixels->Color( **G, R, B** )`（GRB順）に注意
- **トークン長**：各 `dat[i]` は **最大9文字＋終端**。超過は切り捨てられる（送信側仕様の徹底）
- **命名**：RAII 変数は `*_guard`（例：`serial_guard` / `led_guard`）で統一すると可読性向上
