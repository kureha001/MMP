# filename : Presen.py
# =========================================
# Ｐ層(プレゼンテーション層)
# 様々なエフェクトや操作を提供する
# -----------------------------------------
#  Phase 2.8 : ファイル分割
# =========================================
from   machine import Pin, PWM, I2C
from   time    import sleep_ms
import ssd1306

import  Data       as D層  # D層(データベース層)

# ------------------------
# ハード構成（ESP32-S3 Tiny）
# ------------------------
# LED 各色2個(赤,青,黄,緑)
PIN_LED       = [(44,43),(18,17),(14,13),(12,11)]
PIN_I2C_SCL   = 15              # I2C/OLED
PIN_I2C_SDA   = 16              # I2C/OLED
PIN_SOUNDER   = 1               # 電圧サウンダー
PIN_BTN_START = 2               # ボタン：スタート
PIN_BTN_COLOR = [10, 9, 8, 7]   # ボタン：色別(赤,青,黄,緑)

# ------------------------
# デバイス初期化：I2C/OLED
# ------------------------
i2c  = I2C(1, scl=Pin(PIN_I2C_SCL), sda=Pin(PIN_I2C_SDA), freq=400000)
oled = ssd1306.SSD1306_I2C(64, 32, i2c)

# ------------------------
# デバイス初期化：LED
# ------------------------
pinLed_A = [Pin(a, Pin.OUT) for (a, b) in PIN_LED]
pinLed_B = [Pin(b, Pin.OUT) for (a, b) in PIN_LED]

# ------------------------
# デバイス初期化：サウンダ
# ------------------------
spk = PWM(Pin(PIN_SOUNDER))
spk.freq(1000)
spk.duty_u16(0)
音色_色別   = [262, 294, 330, 349] # 赤=ド/青=レ/黄=ミ/緑=ファ）

# ------------------------
# デバイス初期化：ボタン
# ------------------------
pinBtnスタート  = Pin(PIN_BTN_START, Pin.IN, Pin.PULL_UP)
pinBtn色別      = [Pin(p, Pin.IN, Pin.PULL_UP) for p in PIN_BTN_COLOR]
押下LED点灯時間 = 120   # 押下LED短点灯
押下待ち時間    = 20    # ボタン・デバウンス


# =========================================
# ヘルパー
# =========================================
# ------------------------
# "S.mm" 形式文字列
# ------------------------
def getStr時間(ms):
    cs = (ms + 5) // 10 # 1cs=10ms。+5で四捨五入
    sec = cs // 100
    cc  = cs % 100
    return "{}.{:02d}s".format(sec, cc)

# ------------------------
# ミス カウント文字列取得
# ------------------------
def getStrミス():
    ミス = D層.状況["ミス回数"  ]
    上限 = D層.出題["ミス上限数"]
    if 上限 < 0: return "MIS{}/{}".format(ミス, 上限)[:8]
    else       : return "MISS {}".format(ミス)[:8]

# ------------------------
# 進捗文字列取得
# ------------------------
def getStr進捗():
    正答数 = D層.状況["ステップ数"]
    全長   = len(D層.出題["問題"])
    return "STP{}/{}".format(正答数, 全長)


# =========================================
# ＯＬＥＤ表示
# =========================================
# ------------------------
# ベース(生データ)
# ------------------------
def showRaw(l1, l2, l3):
    oled.fill(0)
    if l1: oled.text(l1[:8], 0, 0)
    if l2: oled.text(l2[:8], 0, 12)
    if l3: oled.text(l3[:8], 0, 24)
    oled.show()
# ------------------------
# 全画面消去 
# ------------------------
def oled消去():
    oled.fill(0)
    oled.show()

# =========================================
# 複合エフェクト：WEB-API用
# =========================================
# ------------------------
# 参加受理通知(state=standby)
# ------------------------
def api参加受理通知():
    showRaw("READY", "#" + str(D層.基本["背番号"]), "")
# ------------------------
# ゲーム開始通知(state=playing)
# ------------------------
def apiゲーム開始通知():
    #┬
    #◎LEDと音で出題内容をする
    for c in D層.出題["問題"]:

        # 音を鳴らす
        spk.freq(音色_色別[c])
        spk.duty_u16(30000)

        # LEDを交互に点滅
        a = pinLed_A[c]; b = pinLed_B[c]
        for _ in range(10):
            a.value(1); b.value(0); sleep_ms(20)
            a.value(0); b.value(1); sleep_ms(20)

        # 音・LEDを停止
        spk.duty_u16(0)
        a.value(0); b.value(0)
        sleep_ms(200)  # 間隔
    #┴
# ------------------------
# ゲーム結果通知(state=ending)
# ------------------------
def apiゲーム結果通知():
    showRaw(
        "[RESULT]",
        "No.{}/{}".format(D層.結果["順位"], D層.結果["参加数"]),
        ""
        )

# =========================================
# 複合エフェクト：画面用
# =========================================
# ------------------------
# 開始待ち(state=idle)
# ------------------------
def 開始待ち():
    現在位置    = D層.画面["現在位置"]
    IPアドレス  = D層.画面["IP"][現在位置:現在位置+8]
    ポート番号  = "PORT" + str(D層.ネット["PORT"])
    showRaw("ONLINE", IPアドレス, ポート番号)
    snd_押下()

# ------------------------
# 競技中(state=playing)
# ------------------------
# [標準]用
def 競技中_標準():
    showRaw(
        "PLAYING"   ,
        getStr進捗(),
        getStrミス(),
        )
    sleep_ms(D層.出題["ペナルティ"])
# ------------------------
# [ミス]用
def 競技中_ミス():
    showRaw(
        "MISS!!",
        getStr進捗(),
        getStrミス(),
        )
    snd_ミス()
    競技中_標準()

# ------------------------
# 終了(state=ending)
# ------------------------
# [クリア]用
def 終了_クリア():
    showRaw(
        "[CLEAR]",
        getStr時間(D層.状況["所要時間"]),
        getStrミス()
        )
    snd_全問正解()
# ------------------------
# [時間切れ]用
def 終了_時間切れ():
    showRaw(
        "[TIMEUP]",
        getStr時間(D層.状況["所要時間"]),
        getStrミス()
        )
    D層.状況["状態"] = "finish"
    snd_失格()
# ------------------------
# [ミス超過]用
def 終了_ミス超過():
    showRaw(
        "[OVER]",
        getStr時間(D層.状況["所要時間"]),
        getStrミス()
        )
    D層.状況["状態"] = "finish"
    snd_失格()

# =========================================
# スピーカー出力
# =========================================
# ------------------------
# ベース(生データ)
# ------------------------
def sndRaw(arg周波数, arg音長):
    spk.freq(arg周波数)
    spk.duty_u16(30000)
    sleep_ms(arg音長)
    spk.duty_u16(0)
# ------------------------
# 単発式
# ------------------------
def snd_押下(): sndRaw(880,  50)
def snd_ミス(): sndRaw(220, 250)
def snd_失格(): sndRaw(196, 500)
# ------------------------
# 複合式：クリア用
# ------------------------
def snd_全問正解():
    for f in (392, 262, 330):
        sndRaw(f, 70)
        sleep_ms(30)

# =========================================
# ＬＥＤ制御
# =========================================
# ------------------------
# 全LED消灯
# ------------------------
def led_全色消灯():
    for a, b in zip(pinLed_A, pinLed_B):
        a.value(0); b.value(0)
# ------------------------
# 色ボタン押下
# ------------------------
def led_色別(arg色ID):
    #①すべて消す
    a = pinLed_A[arg色ID]; b = pinLed_B[arg色ID]
    led_全色消灯()
    #②点灯＋クリック音（50ms）
    a.value(1); b.value(0)
    snd_押下()
    #③クリックLEDを点灯
    rest = 押下LED点灯時間 - 50 # クリック音分を差し引く
    if rest > 0: sleep_ms(rest)
    a.value(0); b.value(0)

# =========================================
# ボタン押下
# =========================================
# -----------------------------------------
# カラーボタン用
# 引数：① 色ID
# 戻値：① 結果(True=押下あり/False=押下なし)
# -----------------------------------------
def btn_色押下(arg色ID):
    if pinBtn色別[arg色ID].value() == 0:
        sleep_ms(押下待ち時間)
        if pinBtn色別[arg色ID].value() == 0: return True
    return False
# -----------------------------------------
# ボタン押下色ID取得
# 引数：なし
# 戻値：① 結果(True=押下あり/False=押下なし)
# 　　　② 色ID(-1:押下無し)
# -----------------------------------------
def btn_色スキャン():
    #┬
    #◎└┐全色を順次に処理
    for idx, pin in enumerate(pinBtn色別):
        #│
        #◇┐当該ボタンを走査
        if pin.value() == 0:
            sleep_ms(押下待ち時間)  # チャタリング対応１
            if pin.value() == 0:    # チャタリング対応２
        #　├→(ボタン押下の場合)
                #○LEDを点灯する
                #▼RETURN:[押下あり][色ID]を返す
                led_色別(idx)
                sleep_ms(50)
                return True, idx
    #│
    #▼RETURN:[押下なし]を返す
    return False, -1
    #┴
# -----------------------------------------
# スタートボタン用
# 引数：なし
# 戻値：なし
# -----------------------------------------
def btn_スタート押下待ち():
    #┬
    #◎└┐全色を順次に処理
    while True:
        if pinBtnスタート.value() == 0:
            sleep_ms(押下待ち時間)
            if pinBtnスタート.value() == 0:
                while pinBtnスタート.value() == 0: sleep_ms(5)
                return
        sleep_ms(5)