//=============================================================================
//  Ardipy MMPエディション
//-----------------------------------------------------------------------------
// Ver 0.01.006　2025/04/28 By Takanari.Kureha
//      1.PCA9685が48枚超で動作しないのでアドレスパターンを減らした
//=============================================================================
#include <Wire.h>
#include <PCA9685.h>            //PCA9685用ヘッダーファイル（秋月電子通商作成）

//=============================================================================
#define BAUDRATE 921600
const char* Version = "1.1!!";
int input_count = 0;

//=============================================================================
//PCA9685のアドレス・パターン
const int PWM_COUNT = 48;
PCA9685 PWM[PWM_COUNT] = {
    PCA9685(0x40), PCA9685(0x41), PCA9685(0x42), PCA9685(0x43), PCA9685(0x44),
    PCA9685(0x45), PCA9685(0x46), PCA9685(0x47), PCA9685(0x48), PCA9685(0x49),
    PCA9685(0x4A), PCA9685(0x4B), PCA9685(0x4C), PCA9685(0x4D), PCA9685(0x4E),
    PCA9685(0x4F), PCA9685(0x50), PCA9685(0x51), PCA9685(0x52), PCA9685(0x53), 
    PCA9685(0x54), PCA9685(0x55), PCA9685(0x56), PCA9685(0x57), PCA9685(0x58),
    PCA9685(0x59), PCA9685(0x5A), PCA9685(0x5B), PCA9685(0x5C), PCA9685(0x5D),
    PCA9685(0x5E), PCA9685(0x5F), PCA9685(0x60), PCA9685(0x61), PCA9685(0x62),
    PCA9685(0x63), PCA9685(0x64), PCA9685(0x65), PCA9685(0x66), PCA9685(0x67),
    PCA9685(0x68), PCA9685(0x69), PCA9685(0x6A), PCA9685(0x6B), PCA9685(0x6C),
    PCA9685(0x6D), PCA9685(0x6E)
    };

#define SERVOMIN 150            //最小パルス幅 (標準的なサーボパルスに設定)
#define SERVOMAX 600            //最大パルス幅 (標準的なサーボパルスに設定)

//=============================================================================
void setup(){
    // put your setup code here, to run once:
    Wire.begin();
    Serial.begin(BAUDRATE);

    //★PCA9685
    for (int i = 0; i < PWM_COUNT; i++) {
      PWM[i].begin();         //初期設定
      PWM[i].setPWMFreq(60);  //PWM周期を60Hzに設定
    }
}

//=============================================================================
void loop() {

  char *lexeme;
  char  input[30];   // 文字列格納用
  char  str[5][10];
  char  rets[30];
  long  voltage;
  int   i;

  //★PCA9685
  int   pwmNo;   // 使用ポート
  int   pwmAn;   // 角度
  int   pwmID;   // 角度
  int   pwmCh;   // 角度

  //◇
  //├→(シリアル通信が有効な場合)
  if (Serial.available()) {

    //〇シリアルデータを配列変数に格納する
    input[input_count] = Serial.read();

    //◇
    if (input_count > 30 || input[input_count] == '!') {
    //├→(文字数が30以上 or 末尾文字)

      //〇読み取ったデータの末尾に終端文字を挿入する
      input[input_count] = '\0';

      //◎データを分割する。
      for(lexeme = strtok(input, ":"); lexeme; lexeme = strtok(NULL, ":")) {
        strcpy(str[i], lexeme);
        i=i+1;
      }

      input_count = 0;
      i=0;

      //=======================================================================
      // ＰＷＭエキスパンダ(PCA9685)
      //-----------------------------------------------------------------------
      // ・[0]:PWM
      // ・[1]:ポート番号
      // ・[2]:出力値(角度)
      //=======================================================================
      if(strcmp(str[0], "PWM")==0){
          pwmNo = atoi16(str[1]);       // 総チャンネルの通し番号
          pwmAn = atoi16(str[2]);       // 角度
          pwmAn = map(pwmAn, 0, 180, SERVOMIN, SERVOMAX);
          pwmID = pwmNo / 16;           // PCA9685の位置
          pwmCh = pwmNo - (16 * pwmID); // チャンネル位置

          if (pwmID < PWM_COUNT){
            PWM[pwmID].setPWM(pwmCh, 0, pwmAn);
            Serial.print("!!!!!");
          }else{
            Serial.print("----!");        
          }
      }

      //=======================================================================
      // デジタル入出力
      //=======================================================================
      //-----------------------------------------------------------------------
      // 出力
      // ・[0]:ADR
      // ・[1]:ポート番号
      // ・[2]:出力値(1or0)
      // ・5byte return
      //-----------------------------------------------------------------------
      else if(strcmp(str[0], "POW")==0){
         pinMode(atoi16(str[1]), OUTPUT);
         digitalWrite(atoi16(str[1]), atoi16(str[2]));
         Serial.print("!!!!!");
      }
      //-----------------------------------------------------------------------
      // 入力
      // ・[0]:POR
      // ・[1]:ポート番号
      // ・5byte return
      //-----------------------------------------------------------------------
      else if(strcmp(str[0], "POR")==0){
         pinMode(atoi16(str[1]), INPUT);
         unsigned char retb = digitalRead(atoi16(str[1]));
         sprintf(rets, "%01x!!!!", retb); 
         Serial.print(rets);
      }
      //=======================================================================
      // アナログ入力
      // ・[0]:ADR
      // ・[1]:ポート番号
      // ・5byte return
      //=======================================================================
      else if(strcmp(str[0], "ADR")==0){
         word retw = analogRead(atoi16(str[1]));
         sprintf(rets, "%03x!!", retw); 
         Serial.print(rets);
      }
      //=======================================================================
      // VER(version)
      // ・5byte return
      //=======================================================================
      else if(strcmp(str[0], "VER")==0){
        Serial.print(Version);
      }
      //=======================================================================
      // エラー
      // ・5byte return
      //=======================================================================
      else {
        Serial.print("----!");        
      }
    }
    else { input_count++; }
  }
}

//=======================================================================
// 文字エンコード
//=======================================================================
int atoi16( const char *NumberString )
{
    char *stopString;
    int result = strtol( NumberString, &stopString, 16 );
    return result;
}

#define NELEMS(arg) (sizeof(arg) / sizeof((arg)[0]))