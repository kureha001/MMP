//=============================================================================
//  Ardipy MMPエディション
//-----------------------------------------------------------------------------
// Ver 0.01.007　2025/04/28 By Takanari.Kureha
//   ・RP2350系のコンパイルに対応 ※動作せず
//=============================================================================
#include <Wire.h>
#include <PCA9685.h>            //PCA9685用ヘッダーファイル（秋月電子通商作成）

int inp_cnt = 0;

//=============================================================================
//PCA9685
//=============================================================================
//□パルス幅
#define SERVOMIN 150  //最小 (標準的なサーボパルスに設定)
#define SERVOMAX 600  //最大 (標準的なサーボパルスに設定)

//□アドレス・パターン数
const int PWM_COUNT = 48;

//□アドレス・パターン
PCA9685 PWM[PWM_COUNT] = {
    PCA9685(0x40), PCA9685(0x41), PCA9685(0x42), PCA9685(0x43), PCA9685(0x44),
    PCA9685(0x45), PCA9685(0x46), PCA9685(0x47), PCA9685(0x48), PCA9685(0x49),
    PCA9685(0x4A), PCA9685(0x4B), PCA9685(0x4C), PCA9685(0x4D), PCA9685(0x4E),
    PCA9685(0x4F), PCA9685(0x50), PCA9685(0x51), PCA9685(0x52), PCA9685(0x53), 
    PCA9685(0x54), PCA9685(0x55), PCA9685(0x56), PCA9685(0x57), PCA9685(0x58),
    PCA9685(0x59), PCA9685(0x5A), PCA9685(0x5B), PCA9685(0x5C), PCA9685(0x5D),
    PCA9685(0x5E), PCA9685(0x5F), PCA9685(0x60), PCA9685(0x61), PCA9685(0x62),
    PCA9685(0x63), PCA9685(0x64), PCA9685(0x65), PCA9685(0x66), PCA9685(0x67),
    PCA9685(0x68), PCA9685(0x69), PCA9685(0x6A), PCA9685(0x6B), PCA9685(0x6C),
    PCA9685(0x6D), PCA9685(0x6E)
    };

//=============================================================================
// 初期処理
//=============================================================================
void setup(){
    // put your setup code here, to run once:
    Wire.begin();
    Serial.begin(921600);

    //★PCA9685
    for (int i = 0; i < PWM_COUNT; i++) {
      PWM[i].begin();         //初期設定
      PWM[i].setPWMFreq(60);  //PWM周期を60Hzに設定
    }
}

//=============================================================================
// メイン処理
//=============================================================================
void loop() {

  //★PCA9685
  int   pwmNo;        // 総合ポートNo
  int   pwmAn;        // 角度
  int   pwmID;        // アドレスリスト添え字
  int   pwmCh;        // ボード別ポートNo

  char  input[30];    // 受信文字列
  char  dat[5][10];   // 項目データ

  char  *div_dat;     // 項目分割ワーク
  int   dat_cnt;      // 項目データカウンタ

  char  rets[30];     // 返信用文字列

  //◇
  if (Serial.available()) {
  //├→(シリアル通信が有効な場合)

    //〇シリアルデータを配列変数に格納する
    input[inp_cnt] = Serial.read();

    //◇１通信を受信し終えたら、コマンド処理する。
    if (inp_cnt > 30 || input[inp_cnt] == '!') {
    //├→(30データ以上 または 終端文字を検出)

      //〇末尾データを終端文字で上書きする
      input[inp_cnt] = '\0';

      //〇カウンタをゼロ初期化する
      inp_cnt = 0;
      dat_cnt = 0;

      //◎受信文字列を項目単位に分割する
      for(div_dat = strtok(input, ":"); div_dat; div_dat = strtok(NULL, ":")) {
        //〇項目データに格納する
        strcpy(dat[dat_cnt], div_dat);
        dat_cnt++;
      }

      //=======================================================================
      //【データ】[0]:"PWM"・・・ＰＷＭ出力(PCA9685)
      //         [1]:総合ポート番号
      //         [2]:出力値(角度)
      //【返　信】[正常終了("!!!!!")｜異常終了("----!")]
      //=======================================================================
      if( strcmp( dat[0], "PWM" ) == 0 ){                     // コマンド識別
          pwmNo = atoi16(dat[1]);                             // 総合ポート番号
          pwmAn = atoi16(dat[2]);                             // 角度
          pwmAn = map(pwmAn, 0, 180, SERVOMIN, SERVOMAX);     // PWM値に変換
          pwmID = pwmNo / 16;                                 // ボード特定
          pwmCh = pwmNo - (16 * pwmID);                       // ポート特定

          if ( pwmID < PWM_COUNT ){
            PWM[pwmID].setPWM( pwmCh, 0, pwmAn );             // ポート出力
            Serial.print( "!!!!!" );                          // 正常を返信
          }else{
            Serial.print( "----!" );                          // 異常を返信
          }
      }
      //=======================================================================
      //【データ】[0]:"POW"・・・デジタル出力
      // 　　　　 [1]:ポート番号
      //         [2]:出力値(1or0)
      //【返　信】正常終了("!!!!!")
      //=======================================================================
      else if(strcmp(dat[0], "POW")==0){                      // コマンド識別
         pinMode(atoi16(dat[1]), OUTPUT);                     // ポート割当
         digitalWrite(atoi16(dat[1]), atoi16(dat[2]));        // ポート出力
         Serial.print("!!!!!");                               // 正常を返信
      }
      //=======================================================================
      //【データ】[0]:"POR"・・・デジタル入力
      // 　　　　 [1]:ポート番号
      //【返　信】取得値（16進数1桁＋"!!!!"）
      //=======================================================================
      else if(strcmp(dat[0], "POR")==0){                      // コマンド識別
         pinMode(atoi16(dat[1]), INPUT);                      // ポート割当
         unsigned char retb = digitalRead(atoi16(dat[1]));    // ポート値計測
         sprintf(rets, "%01x!!!!", retb);                     // 計測値を清書
         Serial.print(rets);                                  // 計測値を返信
      }
      //=======================================================================
      //【データ】[0]:"ADR"・・・アナログ入力
      // 　　　　 [1]:ポート番号
      //【返　信】取得値（16進数3桁＋"!!"）
      //=======================================================================
      else if(strcmp(dat[0], "ADR")==0){                      // コマンド識別
         word retw = analogRead(atoi16(dat[1]));              // ポート値計測
         sprintf(rets, "%03x!!", retw);                       // 計測値を清書
         Serial.print(rets);                                  // 計測値を返信
      }
      //=======================================================================
      // エラー発生
      //【返　信】異常終了("----!")
      //=======================================================================
      else {
        Serial.print( "----!" );                                // 異常を返信
      }
    } else {
      //〇受信項目数を増やす
      inp_cnt++;
    }
  }
}

//=======================================================================
// 文字エンコード
//=======================================================================
int atoi16( const char *NumberString ){
    char *stopString;
    int result = strtol( NumberString, &stopString, 16 );
    return result;
}